# Microsevice Orchestration Modeling,Verification and Validation
## Motivation

&emsp;&emsp;在微服务架构下，服务是独立而自治的个体，要通过编排的方式让他们彼此之间进行协作。对于一个复杂系统的开发，首先要利用设计方法建模自己的业务流程，划分出多个接口实现，最后对接口进行调试。与传统应用不同的是，在微服务架构中，不仅涉及到前后端之间的接口交互调试，也涉及到后端系统之间API的相互调用，而这个调用可能是很长很深的，当测试出现问题时，由于彼此之间的调用是内嵌于代码之中的，所以可见性是很差的，要通过类似Zipkin之类的工具对调用链中的每一环进行一定的日志信息记录，再从日志信息中排查哪段调用出了问题。在发现问题后，要通过修改大量的代码来进行debug，可能修改过程中要涉及到很多微服务的修改。  
&emsp;&emsp;所以应该在建模到实际开发协作的代码中间加上一个预测试的过程，在这个步骤中，设计师有两个问题想要得到回答：我设计的微服务编排过程是否是可行的？是否是优秀的？

## Idea
&emsp;可以提供一个编排器（Choreographer）给架构师使用，这个编排器包含三部分：建模器、验证器、评价器。他可以在Modeler的画布中建立业务微服务的表述、结合一定的系统服务来描述自己的微服务调用流程，在添加上必要的属性后传给验证器，在验证器中能够编排流程图并且自动执行完成，在执行过程中会记录各种运行时信息，这些信息也会展示给使用者。在执行完成后如果结果是失败或者输出不符合设计的初衷，那么设计人员就可以根据运行时信息去找哪一步出现问题，而不用等到实际开发完成再实际调试。对于评价器（暂定），可以根据设计的结构图进行评价（已经有根据zipkin生成的调用图对微服务体系架构进行评价的一些研究），也可以根据运行时信息设计一些评价标准。

## Implementation
 第一步:提出一种用于描述微服务编排的DSL，同时设计Case。  
（一）DSL的目的：  
1.描述服务之间的协作运行流程。  
2.定义微服务信息（Name、URL、Input、Output、Retry、Timeout、FallBack）和系统任务信息。  
3.提供给验证器验证、DSL执行引擎执行。  
（二）DSL的使用者、设计完的输出、Start与End  
使用者是架构师或者MSA设计师。  
最终输出是一张图片用于展示，以及一个json格式的文件用于执行。  
Start是一些自定义的参数（可以理解为是之前的微服务传递过来的参数信息）。  
End是期望得到的结果。  
（三）与结果是workflow的编排形式（BPMN及类似）的区别与联系  
1.联系：都是基于流程的，对于流的描述语法和设计思想有相通之处（如流程、子流程、网关、事件等）  
2.区别：不涉及到人工的单元，输入与输出不仅是一个状态节点，而是携带信息的。  
第二步：实现DSL Parser，能够对定义的流程进行解析（把所定义的不同的节点和属性对应到类实例和类属性）。  
第三步：实现流程的自动执行，涉及到两个方面，调用（流程执行过程中涉及到很多的网络调用，要求的性能很高，初步调研可以用Akka或者Netty）和中间结果的解析与保存。    



后续步骤在之前的基础上推进，    
（1）理想的Modeler要提供页面供操作。  
（2）形式化方法给出验证和评价（功能点和标准还要再设计）  
…………………….  
（n）自动生成代码方向，可以把编排结果自动构建成web服务  

## Related Work
An extensible data-driven approach for evaluating the quality of microservice architectures  
Beethoven: An Event-Driven Lightweight Platform for Microservice Orchestration  
Evaluation of Microservice Architectures: A Metric and Tool-Based Approach  
